/*
 *  Part of the Parabix Project, under the Open Software License 3.0.
 *  SPDX-License-Identifier: OSL-3.0
 */

#pragma once

#include <kernel/basis/p2s_kernel.h>
#include <kernel/streamutils/collapse.h>
#include <kernel/streamutils/deletion.h>
#include <kernel/pipeline/pipeline_builder.h>

namespace kernel {
namespace streamutils {

/**
 * Multiplexes a set of `basis` streams into a single stream of `i8` codes.
 * 
 * This operation differs from parallel to serial in that a `FilterByMask` is
 * first performed on the basis streams where the mask is a collapsed version 
 * of the basis streams.
 * 
 * Because this function filters by a mask generated by a collapsed `basis` set,
 * the resultant code stream will not contain any 0x0 codes. To perform a
 * multiplex operation using a custom mask see `MultiplexWithMask`.
 * 
 * Preconditions:
 *  - field width of `basis` == 1
 *      i.e., `basis` must be a bitstream set
 *  - number of streams in `basis` <= 8
 *      This is due to a limitation of the `P2SKernel` used to generated i8 codes.
 *      TODO: possibly template this function to allow different serializers.
 * 
 * Returns:
 *  - A single i8 stream (i.e., <i8>[1])
 * 
 * Multiplex Process:
 *  Input:
 *      basis[0]:   1...1...
 *      basis[1]:   1.......
 *      basis[2]:   ..1..1..
 *      basis[3]:   ..1.1...
 * 
 *  Collapse:
 *      mask:       1.1.11..
 * 
 *  Filter By Mask:
 *      basis[0]':  1.1.
 *      basis[1]':  1...
 *      basis[2]':  .1.1
 *      basis[3]':  .11.
 * 
 *  Multiplex:
 *      codes:      0x3, 0xC, 0x9, 0x4
 */
inline StreamSet * Multiplex(std::unique_ptr<ProgramBuilder> & P, StreamSet * basis) {
    assert(basis->getFieldWidth() == 1);
    assert(basis->getNumElements() <= 8);

    StreamSet * mask = Collapse(P, basis);
    StreamSet * filtered = P->CreateStreamSet(basis->getNumElements(), 1);
    FilterByMask(P, mask, basis, filtered);
    StreamSet * codes = P->CreateStreamSet(1, 8);
    P->CreateKernelCall<P2SKernel>(filtered, codes);
    return codes;
}


/**
 * Multiplexes a `basis` stream set into a stream of `i8` codes using a given
 * `mask`.
 * 
 * The provided `mask` is passed to `FilterByMask` to compress the `basis`
 * streams before turning them into codes.
 * 
 * Multiplex Processes:
 *  Input:
 *      basis[0]:   1...1...
 *      basis[1]:   1.......
 *      basis[2]:   ..1..1..
 *      basis[3]:   ..1.1...
 * 
 *      mask:       1.1111..
 * 
 *  Filter By Mask:
 *      basis[0]':  1..1.
 *      basis[1]':  1....
 *      basis[2]':  .1..1
 *      basis[3]':  .1.1.
 * 
 *  Multiplex:
 *      codes:      0x3, 0xC, 0x0, 0x9, 0x4
 */
inline StreamSet * MultiplexWithMask(std::unique_ptr<ProgramBuilder> & P, StreamSet * basis, StreamSet * mask) {
    assert(basis->getFieldWidth() == 1);
    assert(basis->getNumElements() <= 8);
    assert(mask->getFieldWidth() == 1);
    assert(mask->getNumElements() == 1);

    StreamSet * filtered = P->CreateStreamSet(basis->getNumElements(), 1);
    FilterByMask(P, mask, basis, filtered);
    StreamSet * codes = P->CreateStreamSet(1, 8);
    P->CreateKernelCall<P2SKernel>(filtered, codes);
    return codes;
}

}} // namespace kernel::streamutils
