/* namechars.h - Bitset maps for name characters.
    Copyright (c) 2008, 2010 Robert D. Cameron.
    Licensed to the public under the Open Software License 3.0.
    Licensed to International Characters, Inc., under the Academic
    Free License 3.0.
    
    This is a generated file using xml_chars.py.  Do not edit.
    
    The XML10 maps apply to XML 1.0 4th edition and prior.
    The XML11 maps apply to XML 1.1 and the proposed XML 1.0 5th edition.

*/
#ifndef NAMECHARS_H
#define NAMECHARS_H
unsigned char NameStrt_XML10_0000_11FF[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFE,
    0x7F, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x8C, 0x3F,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x1F,
    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0xEB, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFE, 0xFE, 0x2A, 0xBF, 0xFF, 0xF0, 0x00,
    0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF,
    0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF9, 0x98, 0xFF, 0xFF, 0xFF, 0xF3, 0xFC, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
    0xFF, 0xFF, 0xFE, 0x40, 0x7F, 0xFF, 0xFF, 0xFF,
    0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xE0,
    0x7F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E,
    0xFF, 0xFE, 0xF4, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC4,
    0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00,
    0x07, 0xF9, 0x9F, 0xFF, 0xFF, 0xBF, 0xA3, 0xC0,
    0x00, 0x00, 0x00, 0x0D, 0xC0, 0x00, 0xC0, 0x00,
    0x07, 0xE1, 0x9F, 0xFF, 0xFF, 0xBF, 0xB6, 0xC0,
    0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x38, 0x00,
    0x07, 0xF5, 0xDF, 0xFF, 0xFF, 0xBF, 0xB7, 0xC4,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x07, 0xF9, 0x9F, 0xFF, 0xFF, 0xBF, 0xB3, 0xC4,
    0x00, 0x00, 0x00, 0x0D, 0xC0, 0x00, 0x00, 0x00,
    0x07, 0xE3, 0xBC, 0x6B, 0x18, 0xE3, 0xFD, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0xFB, 0xBF, 0xFF, 0xFF, 0xBF, 0xF7, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
    0x07, 0xFB, 0xBF, 0xFF, 0xFF, 0xBF, 0xF7, 0xC0,
    0x00, 0x00, 0x00, 0x02, 0xC0, 0x00, 0x00, 0x00,
    0x07, 0xFB, 0xBF, 0xFF, 0xFF, 0xBF, 0xFF, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xB0, 0x00,
    0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x69, 0xA4, 0x0F, 0x7F, 0x75, 0x36, 0xB0, 0x04,
    0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFC, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00,
    0xB7, 0x5B, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x0A,
    0x80, 0x0A, 0x8C, 0x41, 0xD5, 0x46, 0x34, 0x00,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x93, 0x01, 0xAF,
    0xE0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x80, 0x40};

unsigned char NameStrt_XML10_1E00_1FFF[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0,
    0xFF, 0xFF, 0xFC, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFC, 0xFC, 0xFF, 0x55, 0xFF, 0xFF, 0xFF, 0xFC,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFA,
    0x3B, 0xF8, 0xF3, 0xF0, 0xFF, 0xF8, 0x3B, 0xF8};

unsigned char NameStrt_XML10_2000_21FF[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x32, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

unsigned char NameStrt_XML10_3000_31FF[] = {
    0x01, 0x00, 0x00, 0x00, 0x7F, 0xC0, 0x00, 0x00,
    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xF8, 0x00, 0x7F, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0,
    0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

unsigned char NameChar_XML10_0000_11FF[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xFF, 0xE0,
    0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFE,
    0x7F, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x8C, 0x3F,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x1F,
    0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFC, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
    0x03, 0xEB, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFE, 0xFE, 0x2A, 0xBF, 0xFF, 0xF0, 0x00,
    0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF,
    0xDE, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF9, 0x98, 0xFF, 0xFF, 0xFF, 0xF3, 0xFC, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
    0xFF, 0xFF, 0xFE, 0x40, 0x7F, 0xFF, 0xFF, 0xFF,
    0xFE, 0x00, 0x7F, 0xFF, 0xDF, 0xFF, 0xFF, 0xDD,
    0x68, 0x00, 0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xE0,
    0xFF, 0xFF, 0xE0, 0x00, 0xFF, 0xC0, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E,
    0xFF, 0xFE, 0xF7, 0xFF, 0xFF, 0xBC, 0xFF, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF,
    0xFF, 0xFC, 0x78, 0xFF, 0xF3, 0xFF, 0x00, 0x00,
    0x77, 0xF9, 0x9F, 0xFF, 0xFF, 0xBF, 0xA3, 0xCB,
    0xF9, 0x9C, 0x01, 0x0D, 0xF3, 0xFF, 0xC0, 0x00,
    0x27, 0xE1, 0x9F, 0xFF, 0xFF, 0xBF, 0xB6, 0xCB,
    0xE1, 0x9C, 0x00, 0x7A, 0x03, 0xFF, 0xF8, 0x00,
    0x77, 0xF5, 0xDF, 0xFF, 0xFF, 0xBF, 0xB7, 0xCF,
    0xFD, 0xDC, 0x00, 0x00, 0x83, 0xFF, 0x00, 0x00,
    0x77, 0xF9, 0x9F, 0xFF, 0xFF, 0xBF, 0xB3, 0xCF,
    0xF1, 0x9C, 0x03, 0x0D, 0xC3, 0xFF, 0x00, 0x00,
    0x37, 0xE3, 0xBC, 0x6B, 0x18, 0xE3, 0xFD, 0xC3,
    0xE3, 0xBC, 0x01, 0x00, 0x01, 0xFF, 0x00, 0x00,
    0x77, 0xFB, 0xBF, 0xFF, 0xFF, 0xBF, 0xF7, 0xC3,
    0xFB, 0xBC, 0x06, 0x00, 0xC3, 0xFF, 0x00, 0x00,
    0x37, 0xFB, 0xBF, 0xFF, 0xFF, 0xBF, 0xF7, 0xC3,
    0xFB, 0xBC, 0x06, 0x02, 0xC3, 0xFF, 0x00, 0x00,
    0x37, 0xFB, 0xBF, 0xFF, 0xFF, 0xBF, 0xFF, 0xC3,
    0xF3, 0xBC, 0x01, 0x00, 0xC3, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xE0,
    0xFF, 0xFE, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x69, 0xA4, 0x0F, 0x7F, 0x75, 0x36, 0xFF, 0xDC,
    0xFA, 0xFC, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xC0, 0xFF, 0xC0, 0x05, 0x43,
    0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xC0, 0x7F, 0xFF,
    0xFB, 0xF0, 0xFD, 0x7F, 0xFF, 0xFC, 0x7F, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFC, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00,
    0xB7, 0x5B, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x0A,
    0x80, 0x0A, 0x8C, 0x41, 0xD5, 0x46, 0x34, 0x00,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x93, 0x01, 0xAF,
    0xE0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x80, 0x40};

unsigned char NameChar_XML10_2000_21FF[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xF8, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x32, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

unsigned char NameChar_XML10_3000_31FF[] = {
    0x05, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x7C, 0x00,
    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xF8, 0x66, 0x7F, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE,
    0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

unsigned char NameStrt_XML11_0000_03FF[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFD,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

unsigned char NameChar_XML11_0000_03FF[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xFF, 0xE0,
    0x7F, 0xFF, 0xFF, 0xE1, 0x7F, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};



static inline bool bit_test(const unsigned char bit_Map[], const int codepoint) {
	return (bit_Map[codepoint>>3] >> (7 - (codepoint & 7))) & 1;
}

/*  Is a given codepoint a legal NameStart character in XML 1.0 up to 4th edition? */
static inline bool is_XML10_NameStrt_codepoint(const int codepoint) {
	switch (codepoint >> 12) {
		case 0: return bit_test(NameStrt_XML10_0000_11FF, codepoint);
		case 1: if (codepoint <= 0x11FF)
				return bit_test(NameStrt_XML10_0000_11FF, codepoint);
			else if (codepoint < 0x1E00) return false;
			else return bit_test(NameStrt_XML10_1E00_1FFF, codepoint & 0x1FF);
		case 2:	if (codepoint > 0x2182) return false;
			else return bit_test(NameStrt_XML10_2000_21FF, codepoint & 0x1FF);
		case 3:	if (codepoint > 0x312C) return false;
			else return bit_test(NameStrt_XML10_3000_31FF, codepoint & 0x1FF);
		case 4: return codepoint >= 0x4E00;
		case 5: case 6: case 7: case 8: return true;
		case 9: return codepoint <= 0x9FA5;
		case 0xA: return codepoint >= 0xAC00;
		case 0xB: case 0xC: return true;
		case 0xD: return codepoint <= 0xD7A3;
		default: return false;
	}
}

/*  Is a given codepoint a legal Name character in XML 1.0 up to 4th edition? */
static inline bool is_XML10_NameChar_codepoint(const int codepoint) {
	switch (codepoint >> 12) {
		case 0: return bit_test(NameChar_XML10_0000_11FF, codepoint);
		case 1: if (codepoint <= 0x11FF)
				return bit_test(NameChar_XML10_0000_11FF, codepoint);
			else if (codepoint < 0x1E00) return false;
			else return bit_test(NameStrt_XML10_1E00_1FFF, codepoint & 0x1FF);
		case 2:	if (codepoint > 0x2182) return false;
			else return bit_test(NameChar_XML10_2000_21FF, codepoint & 0x1FF);
		case 3:	if (codepoint > 0x312C) return false;
			else return bit_test(NameChar_XML10_3000_31FF, codepoint & 0x1FF);
		case 4: return codepoint >= 0x4E00;
		case 5: case 6: case 7: case 8: return true;
		case 9: return codepoint <= 0x9FA5;
		case 0xA:	return codepoint >= 0xAC00;
		case 0xB: case 0xC: return true;
		case 0xD: return codepoint <= 0xD7A3;
		default: return false;
	}
}

/*  Is a given codepoint a legal NameStart character in XML 1.0 5e or XML 1.1? */
static inline bool is_XML11_NameStrt_codepoint(const int codepoint) {
	if (codepoint <= 0x03FF) return bit_test(NameStrt_XML11_0000_03FF, codepoint);
	else switch (codepoint >> 12) {
		case 0: case 1: return true;
		case 2:	if (codepoint >= 0x2070)
				if (codepoint <= 0x218F) return true;
				else return (codepoint >= 0x2C00) & (codepoint <= 0x2FEF);
			else return (codepoint >= 0x200C) & (codepoint <= 0x200D);
		case 3:	return codepoint >= 0x3001;
		case 4: case 5: case 6: case 7: case 8: case 9: case 0xA: case 0xB: case 0xC: return true;
		case 0xD: return codepoint <= 0xD7FF;
		case 0xE: return false;
		case 0xF: if (codepoint <= 0xFDCF) return codepoint >= 0xF900;
			  else return (codepoint >= 0xFDF0) & (codepoint <= 0xFFFD);
		default: return codepoint <= 0xEFFFF;
	}
}

/*  Is a given codepoint a legal Name character in XML 1.0 5e or XML 1.1? */
static inline bool is_XML11_NameChar_codepoint(const int codepoint) {
	if (codepoint <= 0x03FF) return bit_test(NameChar_XML11_0000_03FF, codepoint);
	else switch (codepoint >> 12) {
		case 0: case 1: return true;
		case 2:	if (codepoint >= 0x2070)
				if (codepoint <= 0x218F) return true;
				else return (codepoint >= 0x2C00) & (codepoint <= 0x2FEF);
			else if (codepoint <= 0x200D) return codepoint >= 0x200C;
			else return (codepoint == 0x203F) | (codepoint == 0x2040);
		case 3:	return codepoint >= 0x3001;
		case 4: case 5: case 6: case 7: case 8: case 9: case 0xA: case 0xB: case 0xC: return true;
		case 0xD: return codepoint <= 0xD7FF;
		case 0xE: return false;
		case 0xF: if (codepoint <= 0xFDCF) return codepoint >= 0xF900;
			  else return (codepoint >= 0xFDF0) & (codepoint <= 0xFFFD);
		default: return codepoint <= 0xEFFFF;
	}
}

/*  Return the number of UTF-8 bytes comprising a legal NameStart character,
    0 if the byte array does not begin with a valid character.  
    Use XML 1.0 rules up to 4th edition */

static inline int XML_10_UTF8_NameStrt_bytes (const unsigned char bytes[]) {
	if (bytes[0] <= 0x7F) {
		if (bit_test(NameStrt_XML10_0000_11FF, (int) bytes[0])) return 1;
		else return 0;
	}
	else if (bytes[0] <= 0xDF) {
		int codepoint = ((bytes[0] & 0x3F) << 6) | (bytes[1] & 0x3F);
		if (bit_test(NameStrt_XML10_0000_11FF, codepoint)) return 2;
		else return 0;
	}
	else if (bytes[0] <= 0xEF) {
		int codepoint = ((bytes[0] & 0x0F) << 12)| ((bytes[1] & 0x3F) << 6) | (bytes[2] & 0x3F);
		return is_XML10_NameStrt_codepoint(codepoint) ? 3 : 0;
	}
	else return 0;
}

/*  Return the number of UTF-8 bytes comprising a legal Name character,
    0 if the byte array does not begin with a valid character.  
    Use XML 1.0 rules up to 4th edition */

static inline int XML_10_UTF8_NameChar_bytes (const unsigned char bytes[]) {
	if (bytes[0] <= 0x7F) {
		if (bit_test(NameChar_XML10_0000_11FF, (int) bytes[0])) return 1;
		else return 0;
	}
	else if (bytes[0] <= 0xDF) {
		int codepoint = ((bytes[0] & 0x3F) << 6) | (bytes[1] & 0x3F);
		if (bit_test(NameChar_XML10_0000_11FF, codepoint)) return 2;
		else return 0;
	}
	else if (bytes[0] <= 0xEF) {
		int codepoint = ((bytes[0] & 0x0F) << 12)| ((bytes[1] & 0x3F) << 6) | (bytes[2] & 0x3F);
		return is_XML10_NameChar_codepoint(codepoint) ? 3 : 0;
	}
	else return 0;
}

/*  Return the number of UTF-8 bytes comprising a legal NameStart character,
    0 if the byte array does not begin with a valid character.  
    Use rules for XML 5th edition/XML 1.1. */

static inline int XML_11_UTF8_NameStrt_bytes (const unsigned char bytes[]) {
	if (bytes[0] <= 0x7F) {
		if (bit_test(NameStrt_XML11_0000_03FF, (int) bytes[0])) return 1;
		else return 0;
	}
	else if (bytes[0] <= 0xDF) {
		int codepoint = ((bytes[0] & 0x3F) << 6) | (bytes[1] & 0x3F);
		return is_XML11_NameStrt_codepoint(codepoint) ? 2 : 0;
	}
	else if (bytes[0] <= 0xEF) {
		int codepoint = ((bytes[0] & 0x0F) << 12)| ((bytes[1] & 0x3F) << 6) | (bytes[2] & 0x3F);
		return is_XML11_NameStrt_codepoint(codepoint) ? 3 : 0;
	}
	else {
		int codepoint = ((bytes[0] & 0x0F) << 18)| ((bytes[1] & 0x3F) << 12) |
				((bytes[2] & 0x3F) << 6) | (bytes[3] & 0x3F);
		return is_XML11_NameStrt_codepoint(codepoint) ? 4 : 0;
	}
}

/*  Return the number of UTF-8 bytes comprising a legal Name character,
    0 if the byte array does not begin with a valid character.  
    Use XML 1.0 rules up to 4th edition */

static inline int XML_11_UTF8_NameChar_bytes (const unsigned char bytes[]) {
	if (bytes[0] <= 0x7F) {
		if (bit_test(NameChar_XML11_0000_03FF, (int) bytes[0])) return 1;
		else return 0;
	}
	else if (bytes[0] <= 0xDF) {
		int codepoint = ((bytes[0] & 0x3F) << 6) | (bytes[1] & 0x3F);
		return is_XML11_NameChar_codepoint(codepoint) ? 2 : 0;
	}
	else if (bytes[0] <= 0xEF) {
		int codepoint = ((bytes[0] & 0x0F) << 12)| ((bytes[1] & 0x3F) << 6) | (bytes[2] & 0x3F);
		return is_XML11_NameChar_codepoint(codepoint) ? 3 : 0;
	}
	else {
		int codepoint = ((bytes[0] & 0x0F) << 18)| ((bytes[1] & 0x3F) << 12) |
				((bytes[2] & 0x3F) << 6) | (bytes[3] & 0x3F);
		return is_XML11_NameChar_codepoint(codepoint) ? 4 : 0;
	}
}

#endif
